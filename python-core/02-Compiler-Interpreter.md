## **Compiler**

- A compiler/interpreter is a program that executes code.

**Execution Model**:

- A **compiler** translates the source code into machine code (binary code) **before** execution.
- Resulting in an **executable file**.

**Execution:** 

- The **CPU** executes the compiled machine code directly.

|  |  **Advantages** | **Disadvantages** | **Example language** |
| --- | --- | --- | --- |
| **Compiler** | • Faster execution | • Slower development | **C** is a compiled language.
|  | • Private code | • No cross-platform support | 

**Steps**:

- Write the source code (e.g., `add.c`).
- Compile the code (e.g., `gcc add.c -o add`).
- Execute the machine code directly (e.g., `./add`).


## **Interpreter**

**Execution Model**:

- An **interpreter** translates the source code into machine code **dynamically**, meaning line-by-line during runtime.

**Execution:**

- The **CPU** executes the machine code generated by the interpreter **line-by-line** during execution.

|  |  **Advantages** | **Disadvantages** | **Example language** |
| --- | --- | --- | --- |
| **Interpreter** | • Faster development | • Slower execution | **JavaScript** is typically interpreted (in browsers or with Node.js).|
| | • Easy to debug | • No privacy for code 
| | • Cross-platform support 

**Steps**:

- Write the source code (e.g., `script.js`).
- Run with the interpreter (e.g., `node script.js` or in a browser).
- The interpreter converts and executes the code line-by-line.


## **Hybrid (Combination of Compilation and Interpretation)**

**Execution Model**:

- The **hybrid model** combines both compilation and interpretation.
- The source code is **compiled** into an intermediate representation (e.g., bytecode),
- which is then executed by an **interpreter** or virtual machine (VM).

**Execution**:

- The **CPU** executes the machine code generated by the interpreter line-by-line, or the interpreter may perform further compilation during runtime (e.g., Just-In-Time (JIT) compilation).

**Advantages**:

- Supports cross-platform
- Faster execution than the interpreter model

**Example Language**:

- **Java** and **Python** use hybrid execution models.

**Steps**:

|  | **Step 1** | **Step 2** | **Step 3** | **Step 4** |
| --- | --- | --- | --- | --- |
| **Java** | Write source code (.java) | Compile to bytecode using javac | JVM loads bytecode | JIT compilation during runtime |
| **Python** | Write source code (.py) | Compile to bytecode (.pyc) | Python interpreter (CPython) executes | No JIT by default in CPython |



## **Why is Python being called Interpreted?**

- Python code is often referred to as "interpreted" because, while it does have an intermediate bytecode stage, it is executed **line-by-line** by the Python interpreter (e.g., **Cpython**).
- No Direct Compilation to Native Machine Code.